> 객체 지향의 유명한 설계 원칙은 다음 5가지가 있습니다.
> 
> 1. 단일 책임 원칙 (SRP)
> 2. **개방 폐쇄 원칙 (OCP)**
> 3. 리스코프 치환 원칙 (LSP)
> 4. 인터페이스 분리 원칙 (ISP)
> 5. 의존관계 역전 원칙 (DIP)
> 
> 이 중에서 2번 `OCP` 원칙
> 
> “**소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**”
> 
> 는 말이 개인적으로 강의를 들어도 헷갈리기도 하고, 정리를 따로 확실히 해두고 싶어졌습니다.정리하는 김에 다른 4가지 원칙들도 이번 기회에 정리해서 문서화작업을 진행하겠습니다!
> 

## SOLID(좋은 객체 지향 설계의 5가지 원칙을 정리)

- SRP : 단일 책임 원칙
- OCP : 개방-폐쇄 원칙
- LSP : 리스코프 치환 원칙
- ISP : 인터페이스 분리 원칙
- DIP : 의존관계 역전 원칙

## SRP 단일 책임 원칙

- **한 클래스는 하나의 책임**만 가져야 함.
- `**변경`을 기준으로. 변경이 있을 때 파급효과가 적으면**, 단일 책임 원칙을 잘 따른 것이다.
- 변경 EX) UI 변경, 객체의 생성과 사용을 분리….

## OCP 개방 - 폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나, `변경에는 닫혀` 있어야 한다.
- 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로
- `다형성`을 활용해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현.
- 지금까지 배운 역할과 구현의 분리를 생각해보자.

### OCP를 지키지 못한 사례

```java
public class MemberService{
	private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

```java
public class MemberService{
	// private MemberRepository memberRepository = new MemoryMemberRepository();
	private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

- MemberService 클라이언트가 구현 클래스를 직접 선택…
- **구현 객체를 변경하려면, 클라이언트 코드를 변경**해야 한다.
- 분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.
- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

## LSP 리스코프 치환의 원칙

- 프로그램 객체는 **프로그램의 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.**
- 자동차 → 엑셀 → 밟으면 앞으로 가야함. (규약에 맞추자.) 뒤로가게 구현하면 원칙 위반.

## ISP 인터페이스 분리 원칙

- **특정 클라이언트를 위한 인터페이스 여러 개**가 범용 인터페이스 하나보다 낫다.
- 자동차 → 운전, 정비 인터페이스로 `분리`
- 사용자 → 운잔자, 정비사 클라이언트로 `분리`
- 분리하면 정비 **인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.**
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

## DIP 의존관계 역전 원칙

- 프로그래머는 `추상화에 의존해야지, 구체화에 의존하면 안된다`
- 구현 클래스에 의존하지 말고, **인터페이스에 의존**하라.
- `역할에 의존해야 한다.` **객체 세상도 클라이언트가 인터페이스에 의존**해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면, 변경이 아주 어려워진다.

### 🤔 `의존한다`의 의미?

= 내가 저 코드를 `안다`
